\subsection{QTHT}

\subsubsection{Foundations}

The building blocks of the syntax of our language will be that of
function-free first order languages, where we have a set of constant
symbols $C$, an infinite set of variables
$X=\{x_i \mid i\in \mathbb{N} \}$, and a set of predicate symbols $P$
with associated arity. We call the union of the set of constants and
variables the set of \emph{terms} $T = C \cup X$. Atoms are built
using predicates, constants and variables, like $p(t_1,\dots, t_n)$
where $p\in P$ is of arity $n$, and $t_i \in T$ for
$\rangecc{i}{1}{n}$. A first order temporal formula is then built from
atoms using the same grammar as for propositional temporal formulas,
along with the additional production rules:

$$
\varphi ::= \forall x \varphi(x) \mid \exists x \varphi(x)
$$

We denote the set of all such formulas as the language
$\mathcal{L}_{T,P}^{\mathcal{T}}$, which we sometimes abbreviate as $\mathcal{L}$
when this does not lead to confusion.

Let $D$ be a non-empty set, called a \emph{domain}. We let $\A(D,P)$
stand for the set of ground atomic sentences constructable from $D$
and $P$. Furthermore, we define an interpretation $\sigma$ of $C$ and
$D$ as a function
$$
\sigma: C \cup D \rightarrow D
$$
such that $\sigma(d) = d$ for all $d \in D$. We call a variable
assignment $\mu$ in $\dsigma$ a mapping from the set of variables $X$ to
$D$, i.e. $\mu \in D^X$. If $\varphi$ has free variables, let $\varphi^\mu$ be the formula
obtained by replacing every free variable $x$ by $\mu(x)$
\cite{agcapevidi17a}.

\begin{definition}[TQHT-structure \cite{agcapevidi17a}]
  A THT $\mathcal{L}$ structure with static domains, or TQHT-structure
  for short, is defined as a tuple $\qthandt$, where for any
  $\kinlambda$ $H_k,T_k \subseteq \A(D,P)$., and $H_k \subseteq T_k$.

  We call a TQHT structure total iff $\bm{H}=\bm{T}$
\end{definition}


The satisfaction relation for TQHT structures is almost completely the
same as that the of THT satisfaction relation defined in section 2, if
one substitutes $\bm{M}=\qthandt$. They differ in the satisfaction
relation for atoms, and additionally TQHT satisfaction is also defined
for for first order quantifiers and equality. These are formalized
below, as stated in \cite{agcapevidi17a}.

\begin{description}
  \item $\bm{M},k \models p(t_1, \dots, t_n) \in \A(C \cup D,P)$ iff $p(\sigma(t_1), \dots, \sigma(t_n))\in H_k$
  \item $\bm{M},k \models t = s$ for any $t,s \in C \cup D$ iff $\sigma(t) = \sigma(s)$
  \item $\qthandt \models \forall x \phi(x)$ iff $\qthandt \models \phi(d)$ for any $d \in D$ and for all $w \in \{\bm{H}, \bm{T}\}$ 
  \item $\bm{M} \models \exists k \phi(x)$ iff $\bm{M} \models \varphi(d)$ for some $d \in D$
\end{description}

The logic induced by the tautologies as per the satisfaction relation
above is called quantified temporal Here-and-There logic with static
domain, or QTHT for short.

Persistence can be proven to hold in TQHT as well.

\begin{proposition}[QTHT Persistence \cite{agcapevidi17a}]
  For any formula $\varphi$, if $\qthandt \models \varphi$, then
  $\qttandt \models \varphi$.
\end{proposition}

First order temporal equilibrium models can be defined in the usual way.

\begin{definition}[First order temporal equilibrium model/stable model \cite{agcapevidi17a}]
  A total TQHT structure $\qttandt$ is a (first order) temporal
  equilibrium model of a theory $\Gamma$ iff $\qttandt \models \Gamma$
  and there is no $\bm{H} < \bm{T}$ such that
  $\qthandt \models \Gamma$.
\end{definition}

We define a first order variant of a temporal rule and temporal program.

\begin{definition}[Universal temporal rule/temporal program] We call
  formulas of the form $\forall x_1, \dots, \forall x_n \varphi$,
  where $\varphi$ is a temporal rule, a \emph{universal temporal rule}. We
  call a set of such formulas a \emph{universal temporal program}.
\end{definition}

We should note that in the logic programming context, we usually
assume that we have a so-called Herbrand structure \cite{peaval06a},
in which we have $\dsigma = \langle C, id \rangle$, where $id$ is the
identity function, i.e. that the constants of the input program
constitute the domain, and that each constant is mapped to itself. We
do not make this assumption where not necessary in the following, and
state the results in their general form.

\subsubsection{Safety}

The usual non-temporal definition of safety requires that each
variable occurring in a rule also occur in a positive literal of the
body of the rule \cite{gekakasc12a}. This safety definition is
extended to a syntactic fragment of temporal formulas in
\cite{agcapevidi17a} by allowing atoms in the scope of a singe $\Next$
to provide safety, and proved that this extended definition satisfied
two key properties that safety guarantees in the non-temporal setting;
namely, the extended definition ensures \emph{domain independence},
and ensures that there are no \emph{unnamed individuals} in the answer
sets of a program \cite{capeva09a} \cite{capeva09b}. Domain
independence states that the answer sets of the program do not change
if they are ground using a superset of the program's constants. This
is important, as otherwise, adding a new rule that one would expect to
have no affect on the answer sets of the program, can still change the
answer sets simply by the virtue of introducing a new constant symbol.

To formalize the second property, given an interpretation $\sigma$, we
call an element of the domain $d \in D$ an \emph{unnamed individual},
iff $d \not\in Im(\sigma\vert_{C})$, i.e. if no constant is mapped to
it by $\sigma$. Now, given a trace $\bm{T}$, we define the restriction
of the trace to the images of the constants in $C$ as
$\bm{T}\vert _C$; that is
$\bm{T}\vert_{Ci} \defeq T_i \cap At(\sigma(C),P)$. A answer set $\bm{T}$
is then said to contain no unnamed individuals iff
$\bm{T} \vert_{C} = \bm{T}$. This property is desirable, as in most
logic programming settings, one would not want arbitrary elements of
the domain to appear in the solutions to a program.

In what follows, we will relax the safety condition even further than
in \cite{agcapevidi17a}, and prove that these desirable properties
still hold, by retracing the steps of the proof the aforementioned
paper. Note that the subformula relation is considered to be reflexive
in what follows, i.e. $\varphi$ is a subformula of $\varphi$ for any
formula $\varphi$. First, we define this extended notion of safety:

\begin{definition}[Safety]
  Given a simple temporal formula $\varphi$, we say a subformula
  $\gamma \in subf(\varphi)$ is in an unsafe position in $\varphi$, if
  it is the immediate subformula of a formula
  $\psi \in subf(\varphi)$, where $\psi$ is of the following form:
  $\psi = \neg \gamma \mid \gamma \vee \xi \mid \xi \vee \gamma \mid
  \gamma \since \xi \mid \gamma \until \xi \mid \gamma \trigger \xi \mid
  \gamma \release \xi$. We furthermore consider any subformulas of
  such a $\gamma$ to be in an unsafe position in $\varphi$. Any
  subformula of $\varphi$ that is not in an unsafe position in
  $\varphi$ is said to be in a \textit{safe position} in $\varphi$. We
  denote the set of such subformulas as $\safe{\varphi}$.

  We call a temporal rule $\varphi = \alwaysF(B \rightarrow H)$
  \emph{safe}, iff each variable $x$ in $\varphi$ occurs in an atom
  that is in a safe position in $B$. We call a universal temporal rule
  $\forallx \psi$ safe iff $\psi$ is safe. We call a program safe, if
  all of it's rules are safe.
\end{definition}

As an example, under this expanded definition of safety, the following
rule would also be considered safe:

\begin{center}
    \begin{lstlisting}[numbers=none]
should_not_shoot(X)  :- since(unloaded(X),prev(shoot(X))).
    \end{lstlisting}
\end{center}

The rule is safe, as \verb|shoot(X)| is an atom which is in a safe
position w.r.t. of the body of the rule, and can thus provide safety
for the single (implicitly) universally quantified variable $X$
occurring in the rule.

We will now embark on the path towards proving the two desirable
properties of the new safety definition. We first prove some
properties of simple temporal formulas.

\begin{lemma}\label{lemma:safe-atomic-subformula-satisfied}
  Let $\varphi$ be a simple temporal formula. If
  $\qthandt,j \models \varphi$, then for all atoms $p$ with
  $p \in \safe{\varphi}$, there exists a $\kinlambda$, such that
  $\qthandt,k \models p$.
\end{lemma}
\begin{proof}
  In the following, let $M=\qttandt$. The property can be shown to
  hold by structural induction on $\varphi$. Clearly, the property
  holds form atoms, $\top$ and $\bot$.

To make the inductive step, let us first consider propositional
connectives. If $\varphi = \psi \wedge \xi$, and $M,j \models
\varphi$, then $M,j \models \psi$ and $M,j \models \xi$. Then applying
the induction hypothesis, for any atoms $p \in \safe{\psi}$ and $q \in
\safe{\xi}$ we must have some $k,l \in \intervcc{0}{\lambda}$ such
that $M,k \models p$ and $M,l \models q$. We can make the
inductive step by noting that $\safe{\psi \wedge \xi} = \safe{\psi}
\cup \safe{\xi}.$ In cases when $\varphi = \psi \vee \xi$ or $\varphi
= \neg \psi$, the property holds trivially, as $\safe{\varphi} =
\emptyset$.

We will now consider past operators; the same argument can be applied
to the dual future versions of these operators. If
$M,j \models \varphi = \previous \psi$, then $M,j-1 \models \psi$, so
we can make the inductive step by applying the induction hypothesis
and noting that $\safe{\previous \psi} = \safe{\psi}$. For the cases
where $\varphi = \psi \since \xi \mid \psi \trigger \xi$, by
inspecting the satisfaction relation for respective the operators, one
can conclude that if $M,j \models \varphi$, then it must be the case
that $M,k \models \xi$ for some $\kinlambda$. Then, applying the
induction hypothesis, and noting that $\safe{\varphi} = \safe{\xi}$
makes the inductive step, and concludes the proof.
  
\end{proof}

\begin{lemma}\label{lemma:t-not-h-atomic-subformula}
  Let $\varphi$ be a simple temporal formula. Then, if
  $\qttandt \models \varphi$ and \\
  $\qthandt \not\models \varphi$, it follow that there is a
  $\kinlambda$ and an atomic subformula $p$ in $F$, such that
  $\qttandt \models p$ and $\qthandt \not\models p$.
\end{lemma}
\begin{proof}
  The property can easily be shown by structural induction on
  $\varphi$. The only step of note is that of $\varphi = \neg \psi$;
  in this case if $\qttandt \models \neg \psi$, then by
  persistence we must have $\qthandt \models \neg \psi$, so the
  property holds trivially.
\end{proof}



\begin{lemma}
  Let $\varphi=\alwaysF (B \rightarrow H)=\alwaysF \psi$ be a temporal
  rule, and $\mu$ a variable assignment in $\dsigma$. If $\varphi$ is
  safe, then $\qttandt,k \models \varphi^\mu$ implies
  $\qttcandt,k \models \varphi^\mu$
\end{lemma}
\begin{proof}
  In the following, let $M=\qttandt$, and $M_C=\qttcandt$.

  Suppose indirectly that $M,k \models \varphi^\mu$, but
  $M_C,k \not \models \varphi^\mu$. Then, there must be some
  $k\leq i$, such that $M,i \models \psi^\mu$ and
  $M_C,i \not \models \psi^\mu$, which must mean that
  $M_C,i \models B^\mu$ and $M_C,i \not \models H^\mu$. By
  persistence, we then have $M,i \models B^\mu$, which means we must
  also have $M,i \models H^\mu$, as we know that
  $M,k \models \alwaysF(B^\mu \rightarrow H^\mu)$. Now, we have found
  that $M,i \models H^\mu$ and $M_C,i \not \models H^\mu$. By applying
  Lemma \ref{lemma:t-not-h-atomic-subformula}, we derive that there is some atomic subformula
  $q$ occurring in $H$, and a $\rangecc{j}{0}{\lambda}$, such that
  $M,j \models q^\mu$ and $M_C,j \not \models q^\mu$. Therefore, we
  must have a variable $x$ in $q$, with $\mu(x) \not \in
  \sigma(C)$. As $x$ is safe, there must be an occurrence of $x$ in an
  atomic formula $p$ in a safe position of $B$. Furthermore, as
  $\mu(x) \not \in \sigma(C)$, we also have $M_C,l \not \models p^\mu$
  for any $\rangecc{l}{0}{\lambda}$. Having determined this fact, we
  can now apply the contraposition of Lemma \ref{lemma:safe-atomic-subformula-satisfied} to derive
  that $M_C,i \not \models B^\mu$, a contradiction that concludes the
  proof.
\end{proof}

From here, we can follow the proof of Proposition 5 and Theorem 2 from \cite{agcapevidi17a} more
or less verbatim to obtain the following results.

\begin{proposition}
  For any safe universal temporal rule $\varphi = \forallx \psi$
  \begin{equation*} \qttandt \models \varphi \text{ iff } \qttcandt \models \varphi. \end{equation*}
\end{proposition}

\begin{theorem}[No Unnamed Individuals]
  If $\varphi$ is a safe universal temporal rule, and $\qttandt$ is a temporal equilibrium
  model of $\varphi$, then $\bm{T}\vert_{C}=\bm{T}$.
\end{theorem}

\subsubsection{Grounding}

Let $(D,\sigma)$ be a domain and $D'\subseteq D$ a finite subset. The
grounding over $D'$ of a sentence $\varphi$, is denoted as
$\ground{D'}{\varphi}$. Grounding is defined to assign each atom to
itself, expand universal/existential quantification
conjunctively/disjunctively over each possible replacement of the
quantified variable by a domain value, and to be operation preserving
w.r.t. all binary and unary logical and temporal
connectives. \cite{agcapevidi17a}. Formally
$\ground{D^{\prime}}{\varphi}$ is defined inductively as follows:

\begin{align*}
  \ground{D^{\prime}}{p} & \defeq p, \text { where } p \text { is an atom } \\
  \ground{D^{\prime}}{\forall x \varphi(x)} & \defeq \bigwedge_{d \in D^{\prime}} \ground{D^{\prime}}{\varphi(d)} \\
  \ground{D^{\prime}}{\exists x \varphi(x)} & \defeq \bigvee_{d \in D^{\prime}} \ground{D^{\prime}}{\varphi(d)} \\
  \ground{D^{\prime}}{\varphi_1 \otimes \varphi_2} & \defeq \ground{D^{\prime}}{\varphi_1} \otimes \ground{D^{\prime}}{\varphi_2}, \\
  \ground{D^{\prime}}{\odot \varphi} & \defeq \odot \ground{D^{\prime}}{\varphi} \\
\end{align*}

for any
$\otimes \in \{ \land, \lor, \rightarrow, \since, \trigger, \until,
\release \}$ and $\odot \in \{ \Next, \previous \}$.

To show that our definition of safety guarantees domain independence
with respect to the formal definition of grounding above, we first
need to prove the following lemma.

\begin{lemma}\label{lemma:not-imsigma-domain-sat}
  Let $\varphi(x)$ be a safe temporal rule, and $\qthandt$ be a TQHT
  structure such that $\bm{T}\vert_{C}=\bm{T}$. Then, for any
  $d \in D \setminus \sigma(C)$, we have

  \begin{equation*}
    \qthandt \models \varphi(d)
  \end{equation*}
  
\end{lemma}

\begin{proof}
  Given a safe temporal rule
  $\varphi(x) = \alwaysF(B(x) \rightarrow H(x))$, by safety, there
  exists some atom $p(x)$ in a safe position of $B(x)$. Now let us
  take a TQHT structure $\qthandt$ such that $\bm{T}\vert_{C}=\bm{T}$
  and a domain element $d \in D \setminus \sigma(C)$. Since
  $\bm{T}\vert_{C}=\bm{T}$, we know that for any $\kinlambda$,
  $\qthandt, k \not \models p(d)$, and therefore by Lemma
  \ref{lemma:safe-atomic-subformula-satisfied} for any
  $\rangecc{j}{0}{\lambda}$ we have $\qthandt,j \not \models B(d)$,
  and as such
  $\qthandt \models \alwaysF(B(x) \rightarrow H(x)) = \varphi(x)$,
  concluding the proof.
\end{proof}

By building upon Lemma \ref{lemma:not-imsigma-domain-sat}and
\ref{lemma:safe-atomic-subformula-satisfied} in the same way as in
\cite{agcapevidi17a}, one can obtain the following results, the final
one showing that our definition of safety guarantees domain independence.

\begin{proposition}
  Let $\varphi = \forallx \psi$ be a safe universal temporal rule and \\
  $\mathcal{M} = \qthandt$ a QTHT structure such that
  $\bm{T}\vert_{C}=\bm{T}$. Then, the following holds:

  \begin{equation*}
    \mathcal{M} \models \varphi \text{ iff } \mathcal{M} \models \ground{C}{\varphi}
  \end{equation*}
\end{proposition}

\begin{proposition}
  Let $\varphi$ be a safe universal temporal rule and
  $\mathcal{M} = \qthandt$ a QTHT structure. Then, $\mathcal{M}$ is a
  first order temporal equilibrium model of $\varphi$ iff
  $\mathcal{M}$ is a first order temporal equilibrium model of
  $\ground{C}{\varphi}$.
\end{proposition}

\begin{theorem}[Domain Independence]\label{theorem:domain-independence}
  Let $\varphi$ be a safe universal temporal rule. Suppose we expand
  the language $\mathcal{L}$ by considering a set of constants
  $C \subseteq C'$. A total QTHT model $\qttandt$ is a temporal
  equilibrium model of $\ground{C}{\varphi}$ iff it is a temporal
  equilibrium model of $\ground{C'}{\varphi}$.
\end{theorem}

In practice, obtaining a ground instantiation of a universal temporal
program using gringo is, as demonstrated at the end of the previous
section, not as straightforward as one might hope. This is due to the
fact that the simplifications performed by the grounding procedure of
gringo are not equivalent under the semantics of QTHT. As a
workaround, we will therefore instead construct a much simpler
positive normal temporal program, and retrieve the ground instances of
our original program from the grounding of this simpler program.

Formally, given a universal temporal rule
$r=\forall x_1 \dots x_n \alwaysF(B \rightarrow H)$, let
$p_1,\dots, p_n$ be the atomic subformulas occurring in a safe
position in $B$, and $h_1, \dots h_m$ the atomic subformulas occurring
in H. The transformation of $r$, denoted as $\delta(r)$ is defined as:

\begin{equation*} \delta(r) =\{ \forall x_1, \dots \forall x_n
\alwaysF(\bigwedge_{j=1}^{n}p_j \rightarrow h_i) \mid
\rangecc{i}{1}{m})\}
\end{equation*}
and $\delta (\Gamma^{\prime})$ the set of all transformed rules. Then, the
following result holds:

\begin{proposition}\label{prop:simplified-facts}
  Let $\qttandt$ be a temporal equilibrium model of a safe temporal
  program $\Gamma$, and $\langle \dsigma, \bm{J},\bm{J} \rangle$ the
  unique temporal equilibrium model of $\delta(\Gamma)$. Then,
  $\bm{T} \subseteq \bm{J}$.
\end{proposition}
\begin{proof}
  
\end{proof}

Proposition \ref{prop:simplified-facts} can be used to obtain a ground
instantiation of $\Gamma$ given $\delta(\Gamma)$ in the following
way. First we obtain the unique temporal equilibrium model $J$ of
$\delta(\Gamma)$, and collect all ground atoms occurring at any time
point in the trace $J$. Note that due to the simple structure of
$\delta(\Gamma)$, the set of ground atoms are identical at any time
point in the trace $J$, as we are essentially just solving the same
positive normal logic program at each time point. Therefore, one does not
even require a temporal answer set solver for this step; one can
simply pass the program $\delta^{\prime}(\Gamma)$ consisting of rules

\begin{equation*} \delta^{\prime}(r) =\{ \forall x_1, \dots \forall x_n
  \bigwedge_{j=1}^{n}p_j \rightarrow h_i) \mid \rangecc{i}{1}{m})\}
\end{equation*}

to clingo to obtain the set of ground atoms.

Once this set of ground atoms have been obtained, they can then be utilized to

Instead of performing this join ourselves, as in \cite{agcapevidi17a},
we use gringo for this purpose, and instead enhance our original
program $\Gamma$ with external statements similar to the form of
$r^{\prime}$, which will ensure that all the ground atoms of
$\Gamma^{\prime}$ are substituted into the program. For each rule
$r^{\prime}$ as above we generate an external statements, as described
in the next subsection.
