\subsection{Metaprogramming Implementation}

Metaprogramming is a generic technique in programming languages, where
an input program is translated, or \emph{reified} into some primitive
datatype of the language. This reified representation then serve as
input to a meta program, which in turn may reinterpret the semantics
of the reified program. The complexity of this translation varies
based on the complexity of the language's syntax. Lisp may serve as a
gold standard here, where reification is simply done by quotation. 

The ASP grounder gringo offers native support for meta-programming by
first grounding the input program, and then serializing a
representation of the ground program as a set of facts
\cite{karoscwa21a}. This set of facts can then be fed as input to a
\emph{meta-encoding}, which can reinterpret the semantics of the
ground language constructs. The transformation $\tau(\Gamma)$
described in the previous section will be implemented by such a
meta-encoding. We will not detail the reification format in this
thesis. For a description of the format, and some examples of simpler
meta-encodings, we refer the reader to \cite{karoscwa21a}.

\subsubsection{Input language}

Syntactically, the input language for meta-telingo is disjunctive
logic programs in the language of the ASP grounder gringo
\cite{PotasscoUserGuide19} \cite{gescth07a}. All rules are implicitly
considered to be in the scope of an $\alwaysF$ operator. Temporal
operators are represented via prefix notation as a symbol. Note that
when we say symbol, we consider symbolic functions as well as symbolic
atoms in the gringo language to be symbols. For a symbol to be
considered a temporal operator two conditions must be met. First, the
names and arities of such symbols must match the written name of the
given operator, and their arity; the written names of the connectives
$\vee, \wedge, \neg$ are considered to be \emph{or, and, neg},
respectively. For example \verb|since(a,b)| corresponds to
$a \since b$. Second, the symbol must not occur nested within a symbol
that is not an operator, i.e. in \verb|dog(next(spotty))|, the
\verb|next/1| is not considered a temporal operator, as \verb|dog/1|
is not an operator.

Let us consider as an example the following temporal rule:
\begin{equation*}
\alwaysF(\textit{shoot} \wedge \textit{unloaded} \since \previous \textit{shoot} 
\rightarrow \eventuallyF \textit{fail} \wedge \alwaysP \textit{forgetful})
\end{equation*}
which states that if at some time point a gun is shot that has
remained unloaded since it's last shot, then the the gun will
eventually fail, and we have determined the shooter to have been
forgetful up until this point. This formula can be represented in the
meta-telingo input language as the following rule:
\begin{center}
    \begin{lstlisting}[numbers=none]
and(eventually_after(fail),since(forgetful,prev(shoot))) 
  :- shoot, since(unloaded,prev(shoot)).
    \end{lstlisting}
\end{center}

This example illustrates a difference in the input language of
meta-telingo versus it's namesake, the temporal ASP system
telingo\cite{cakamosc19a} \cite{agcadipescscvi20a}. Unlike telingo,
meta-telingo does not restrict the input language to
\emph{past-future} rules \cite{agcadipescscvi20a} where the body of a
rule must not contain future operators, and the head of a rule must
not contain past operators.

\subsubsection{Meta Encoding}

Given an input temporal logic program (represented symbolically),
referred to as tap.lp we can obtain it's temporal stable models by
executing the command:

\begin{lstlisting}[language=bash,numbers=none]
clingo tap.lp --output=reify | clingo - meta-telingo.lp -c lambda=<n>
\end{lstlisting}

where \verb|<n>| is some natural number, and sets the trace length
$\lambda$ for the translation. We begin the description of
meta-telingo.lp encoding, which extends over Listing 1 and Listing 2.

\begin{center}
\begin{minipage}{\linewidth}
\begin{lstlisting}[language=clingo, label={lst:meta-telingo-one}]
time(0..lambda-1).

conjunction(B,K) :- literal_tuple(B), time(K),
        hold(L,K) : literal_tuple(B, L), L > 0;
    not hold(L,K) : literal_tuple(B,-L), L > 0.
body(normal(B),K) :- rule(_,normal(B)), conjunction(B,K), 
                     time(K).

hold(A,K) : atom_tuple(H,A) :- rule(disjunction(H),B), 
                               body(B,K), time(K).


true(O,K) :- hold(L,K), output(O,B), literal_tuple(B,L).
hold(L,K) :- true(O,K), output(O,B), literal_tuple(B,L).
true(O,K) :- time(K), output(O,B), not literal_tuple(B,_).

subformula(O) :- output(O,_).
subformula((F;G)) :- subformula((and(F,G);or(F,G);until(F,G);since(F,G))).
subformula(F)	 :- subformula((neg(F);next(F);prev(F))).

true(true,K) :- subformula(true), time(K).
:- subformula(false), time(K), true(false,K).

true(and(F,G),K) :- subformula(and(F,G)), true(F,K), true(G,K).
true((F;G),K) :- subformula(and(F,G)), true(and(F,G),K).
true(or(F,G),K) :- subformula(or(F,G)), true((F;G),K).
true(F,K);true(G,K) :- subformula(or(F,G)), true(or(F,G),K).

true(neg(F),K) :- subformula(neg(F)), time(K), not true(F,K).
not true(F,K) :- subformula(neg(F)), true(neg(F),K).

true(initial,0) :- subformula(initial).
:- true(initial,K), subformula(initial), K!=0.
true(final,lambda-1) :- subformula(final).
:- true(final,K), subformula(final), K!=lambda-1.

true(F,K+1): time(K+1) :- subformula(next(F)), true(next(F),K).
true(next(F),K) :- true(F,K+1), subformula(next(F)), time(K).

true(F,K-1): time(K-1) :- subformula(prev(F)), true(prev(F),K).
true(prev(F),K) :- true(F,K-1), subformula(prev(F)), time(K).

true(until(L,R,J),K): K<=J, time(J)
  :- subformula(until(L,R)), true(until(L,R),K), time(K).
true(until(L,R),K)
  :- subformula(until(L,R)), true(until(L,R,_),K).
true(L,I) :- true(until(L,R,J),K), I=K..J-1.
true(R,J) :- true(until(L,R,J),K).
true(until(L,R,J),K)
  :- subformula(until(L,R)), time(K), time(J), K<=J, true(R,J), 
     true(L,I) : I=K..J-1.

true(since(L,R,J),K): J<=K, time(J)
  :- subformula(since(L,R)), true(since(L,R),K), time(K).
true(since(L,R),K)
  :- subformula(since(L,R)), true(since(L,R,_),K).
true(L,I) :- true(since(L,R,J),K), I=J+1..K.
true(R,J) :- true(since(L,R,J),K).
true(since(L,R,J),K)
  :- subformula(since(L,R)), time(K), time(J), J<=K, true(R,J), 
     true(L,I) : I=J+1..K.
\end{lstlisting}
\captionof{lstlisting}{meta-telingo.lp - part 1}
\end{minipage}
\end{center}

\begin{center}
\begin{minipage}{\linewidth}
  \begin{lstlisting}[language=clingo, label={lst:meta-telingo2}]
derive(wnext(F),or(next(F),final)) :- subformula(wnext(F)).
derive(wprev(F),or(prev(F),initial)) :- subformula(wprev(F)).
derive(eventually_after(F),until(true,F)) 
  :- subformula(eventually_after(F)).
derive(eventually_before(F),since(true,F)) 
  :- subformula(eventually_before(F)).
derive(always_after(F),release(false,F)) 
  :- subformula(always_after(F)).
derive(always_before(F),trigger(false,F)) 
  :- subformula(always_before(F)).
derive(release(L,R),until(R,and(R,or(L,final)))) 
  :- subformula(release(L,R)).
derive(trigger(L,R),since(R,and(R,or(L,initial)))) 
  :- subformula(trigger(L,R)).

subformula(F2) :- derive(F1,F2), subformula(F1).
true(F2,K) :- derive(F1,F2), true(F1,K).
true(F1,K) :- derive(F1,F2), true(F2,K).

#show.
#show (F,K) : subformula(F), not not_atom(F), true(F,K), 
              not output(show,_).
#show (S,K) : output(show(S),B), conjunction(B,K).
#show (S,K) : time(K), output(show(S),B), literal_tuple(B,L), 
              not atom_tuple(_,L).

#defined literal_tuple/1.
#defined literal_tuple/2.
#defined rule/2.
#defined atom_tuple/2.
#defined weighted_literal_tuple/3.
\end{lstlisting}
\captionof{lstlisting}{meta-telingo.lp - part 2}
\end{minipage}
\end{center}

We begin with Listing 1. In the first line, we introduce a helper
predicate \verb|time(K)|, which ranges over the time points of the trace we
are solving for. 

Lines 3-10 correspond to the formulas
$\{ \bigwedge_{k=0}^{\lambda-1} L_{b_1}^k \land \dots \land L_{b_n}
\rightarrow L_{h_1}^k \lor \dots \lor L_{h_m} \mid \tempruleshort \in
\Gamma \} \subset \tau(\Gamma)$. All of the rules are parameterized by
time point, and as such the ground instantiations of these rules will
form a conjunction over all time points, as in the corresponding set
of formulas in $\tau(\Gamma)$. The predicate \verb|hold(L,K)|
corresponds the atoms $L_{b_i}^k$ and $L_{h_j}$ (with a caveat
discussed in the next paragraph).

Lines 13-15 takes care of some technical legwork required for the
implementation. The reification format of gringo represents literals
in the input program as integers \verb|L| in predicates
\verb|literal_tuple(B,L)|. This integer representation is then linked
to it's symbolic representation \verb|O| (a symbolic term in the
gringo language) via the predicate \verb|output(O,B)|. Our translation
will represent the atoms $L_\gamma^k \in \A_{\Gamma,\lambda}^*$ via
\verb|true(O,K)|, where \verb|O| is symbolic representation of
$\gamma$, and \verb|K| is a time point. Lines 13-14 make integer
representation \verb|hold(L,K)| equivalent to the symbolic
representation \verb|true(O,K)|. Line 15 handles an edge case. When,
in \verb|output(O,B)|, \verb|O| is a fact, the reified representation
generates no facts of the form \verb|literal_tuple(B,L)|. Line 15 thus
asserts the truth of such facts for all time points.

Lines 17-19 introduce the predicate \verb|subformula(F)|, which will
range over all formulas $\gamma \in subf^*(\Gamma)$. It starts on line
17 from the formulas occurring in the head and bodies of rules in
$\Gamma$, found in the first argument of \verb|output(O,_)|, and then
recursively collects all subformulas via the recursive rules on lines
18-19. Note that these rules do not collect all subformulas in
$subf^*(\Gamma)$; the derivations of derived operators will be
collected later in the encoding.

The rules in lines 21-61 do not require much explanation as they
express, more or less verbatim, the rules in $\pi^k(\gamma)$ as seen
in Figure \ref{fig:gamma-df-pi}. Note that the predicates
\verb|true(until(L,R,J),K)| and \verb|true(since(L,R,J),K)| correspond
to auxiliary atoms $L^k_{\varphi \until \psi,j}$ and
$L^k_{\varphi \since \psi,j}$, respectively.

Moving on to Listing 2, in lines 1-14, we introduce a new helper
predicate \verb|derive(F1,F2)|. The effect of the rules is the
following. If the formula \verb|F1| occurs as a subformula, and
\verb|F1| has a top-level derived operator, and the derivation of
\verb|F1| is \verb|F2|, then \verb|derive(F1,F2)| will hold. Line 16
adds the derivations of derived operators to the set subformulas,
completing the definition of \verb|subformula/1|. Lines 17-18 assert
that when \verb|derive(F1,F2)| holds, \verb|true(F1,K)| is equivalent
to \verb|true(F2,K)|, completing the translation from $\Gamma$ to
$\tau(\Gamma)$.




\subsubsection{Grounding Challenges}

One limitation of meta-telingo that must be mentioned is introduced by
gringo during the initial grounding and reification of the input
program. As a highly optimized grounder, gringo performs some
simplifications of the input program during grounding. Namely, if
during grounding time it is determined that an atom has no way of
being derived, then all rules with that atom occurring positively in
their bodies are discarded, and all negative occurrences of that atom
in the body of any rule are removed. Furthermore, if an atom is
determined during grounding to hold in all answer sets, and rules with
a negative occurrence of the atom in their body are discarded \cite{gekakasc12a}.

These simplifications preserve the stable models of the input program,
and therefore do not cause any issues outside of reification. However,
these simplifications may not be equivalent according to the semantic
implemented by our meta-encoding, as gringo has no knowledge of these
semantics when performing the aforementioned simplifications. Indeed,
this is the case for meta-telingo as well; for example take the
following temporal program:

\begin{lstlisting}[language=clingo]
a :- prev(b).
b :- initially.
next(c) :- initially.
d :- c.
\end{lstlisting}

Setting $\lambda=2$ the expected temporal answer set for this program
would be the trace $\bm{T}=(\{ b \},\{ a, c, d \})$. However, during
grounding all of the rules of the program would be discarded as
\verb|initially| does not occur in any rule head, and so we would get
an empty trace as the temporal answer set.

Atoms can be guarded from simplification by using clingo's external
statements \cite{PotasscoUserGuide19}, so adding the following
additional statement should help.

\begin{lstlisting}[language=clingo,numbers=none]
#external initially.
\end{lstlisting}

But, unfortunately, the temporal answer set is still just
$\bm{T}=(\{ b \},\{ c \})$. This is due to the fact that gringo during
grounding does not understand the semantic connections between
\verb|next(c)| and \verb|c| or \verb|prev(b)| and \verb|b|, and
therefore concludes the program has no way to derive \verb|prev(b)| or
\verb|c|, and as a result discards the rules on lines 1 and 4. Adding
two more external statements finally gets us the expected result.

\begin{lstlisting}[language=clingo,numbers=none]
#external prev(b).
#external c.
\end{lstlisting}

Having to reason through gringo's simplifications and manually add
external statements is hardly a good user experience for our
system. Fortunately, this issue is addressed and resolved in the
following two section, where we tackle the extension of meta-telingo
to temporal rules with free variables, and present a system for
applying metaprogramming to non-ground ASP programs.
